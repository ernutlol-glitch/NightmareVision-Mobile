package extensions.flixel;

import flixel.addons.ui.FlxUIDropDownMenu;
import flixel.FlxG;
import flixel.addons.ui.FlxUIButton;
import flixel.addons.ui.FlxUI9SliceSprite;
import flixel.addons.ui.StrNameLabel;

/*
	The differences are the following:
	* Support to scrolling up/down with mouse wheel or arrow keys
	* THe default drop direction is "Down" instead of "Automatic"

 */
class FlxUIDropDownMenuEx extends FlxUIDropDownMenu
{
	var currentScroll:Int = 0; // Handles the scrolling
	
	public var canScroll:Bool = true;
	
	public function new(X:Float = 0, Y:Float = 0, DataList:Array<StrNameLabel>, ?Callback:String->Void, ?Header:FlxUIDropDownHeader, ?DropPanel:FlxUI9SliceSprite, ?ButtonList:Array<FlxUIButton>,
			?UIControlCallback:Bool->FlxUIDropDownMenu->Void)
	{
		super(X, Y, DataList, Callback, Header, DropPanel, ButtonList, UIControlCallback);
		dropDirection = Down;
	}
	
	override function updateButtonPositions():Void
	{
		var buttonHeight = header.background.height;
		dropPanel.y = header.background.y;
		if (dropsUp()) dropPanel.y -= getPanelHeight();
		else dropPanel.y += buttonHeight;
		
		var offset = dropPanel.y;
		for (i in 0...currentScroll)
		{ // Hides buttons that goes before the current scroll
			var button:FlxUIButton = list[i];
			if (button != null)
			{
				button.y = -99999;
			}
		}
		for (i in currentScroll...list.length)
		{
			var button:FlxUIButton = list[i];
			if (button != null)
			{
				button.y = offset;
				offset += buttonHeight;
			}
		}
	}
	
	    override function checkClickOff()
    {
        if (dropPanel.visible)
        {
            if (list.length > 1 && canScroll)
            {
                var dragUp:Bool = false;
                var dragDown:Bool = false;

                #if android
                if (FlxG.touches.list.length > 0) {
                    var touch = FlxG.touches.list[0];
                    
                    var diffY = touch.screenY - touch.startScreenY;

                    if (touch.pressed && Math.abs(diffY) > 10) {
                        if (diffY > 0) dragUp = true; 
                        if (diffY < 0) dragDown = true; 
                    }
                }
                #end

                if (FlxG.mouse.wheel > 0 || FlxG.keys.justPressed.UP || dragUp)
                {
                    --currentScroll;
                    if (currentScroll < 0) currentScroll = 0;
                    updateButtonPositions();
                }
                else if (FlxG.mouse.wheel < 0 || FlxG.keys.justPressed.DOWN || dragDown)
                {
                    currentScroll++;
                    if (currentScroll >= list.length) currentScroll = list.length - 1;
                    updateButtonPositions();
                }
            }
            
            #if android
            var startedTouches = FlxG.touches.justStarted();
            if (startedTouches.length > 0 && !startedTouches[0].overlaps(this, getDefaultCamera()))
            {
                showList(false);
            }
            #else
            if (FlxG.mouse.justPressed && !FlxG.mouse.overlaps(this, getDefaultCamera()))
            {
                showList(false);
            }
            #end
        }
    }
	
	override function showList(b:Bool)
	{
		super.showList(b);
		if (currentScroll != 0)
		{
			currentScroll = 0;
			updateButtonPositions();
		}
	}
}
